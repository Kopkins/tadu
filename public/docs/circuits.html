<!DOCTYPE html>
<html>
<head>
	<title>All My Circuits</title>
</head>
<body>
    <div id="first-container" class="container">
        <div id="nav">
            <img src="../img/untitled.png" id="nav-logo" />
            <button id="to-login">LOGIN</button>
        </div>
        <video loop muted autoplay poster="../img/Underground-Traffic.jpg" preload="true">
            <source src="../img/Underground-Traffic.mp4" type="video/mp4" />
        </video>
        <canvas id="splashCanvas"></canvas>
        <div id="splash">TADU</div>
    </div>
    <div class="container">
        Words?
    </div>
    <style type="text/css">

        #nav {
            height: 4em;
            width: 100%;
            background: rgba(24,24,24,0.8);
            position: fixed;
            top: 0;
            z-index: 6;
        }
        #nav-logo {
            height: 100%;
            width: auto;
            padding-left: 2em;
            display: inline-block;
        }
        #to-login {
            color: #FFF;
            border: 1px solid #FFF;
            display: inline-block;
            background: transparent;
            border-radius: 0;
            float: right;
            height: 66%;
            margin: 0.7em 2em;
            font-size: 1em;
            width: 10%;
        }
        .container {
            width: 100%;
            height: auto;
            max-height: 100%;
        }
        canvas {
            position:relative;
            opacity: 0.3;
        }

        video {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          opacity: 0.5;
      }
      video:after{
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.3);
        position: absolute;
        top: 0;
    }

    @media (min-aspect-ratio: 16/9) {
      video {
        height: 300%;
        top: -100%;
    }
}

@media (max-aspect-ratio: 16/9) {
  video {
    width: 300%;
    left: -100%;
}
}

@media (max-width: 767px) {
    #first-container .container {
        background: url('../img/videoframe.jpg') center center / cover no-repeat;
    }

    video {
        display: none;
    }
}
#splash {
    position: absolute;
    top: 30%;
    margin: 0 auto;
    color: #FFF;
    font-family: 'Anivers', sans-serif;
    font-weight: bold;
    z-index: 3;
    font-size: 6em;
    width: 100%;
    text-align: center;
}
</style>
<script type="text/javascript">
 'use strict';

// requestanimation polyfill
(function () {
    var lastTime = 0;
    var vendors = ['webkit', 'moz'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
    }

    if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
            callback(currTime + timeToCall);
        },
        timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
}());

// setup stuff.
var canvas = document.getElementById("splashCanvas"),
ctx = canvas.getContext("2d"),
settings = {
    background: "#0D4D2B",
    traceColor: "#1de9b6",
    traceFill: "#000000",
    startTraces : 30,
    totalTraces : 50,
    redraw: function () {
        reinit();
    }  
};
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

function Trace(settings) {
    settings = settings || {};
    // this.x = settings.x || Math.ceil((Math.random() * width) / 4) * 4;
    // this.y = settings.y || Math.ceil((Math.random() * height) / 4) * 4;
    this.x = window.innerWidth / 2;
    this.y = window.innerHeight / 2;

    this.points = [];
    this.points.push({
        x: this.x,
        y: this.y,
        arc: 0
    });

    this.trapCount = 0;
    this.live = true;

    this.lastPoint = this.points[0];

    this.angle = settings.angle || (Math.ceil((Math.random() * 360) / 45) * 45) * (Math.PI / 180);
    this.speed = 4;
}

Trace.prototype.update = function () {
    var x = this.lastPoint.x,
    y = this.lastPoint.y,
    dx = this.x - x,
    dy = this.y - y;

    // if its greater than .01 keep moving
    if (Math.random() > 0.01) {
        var velX = Math.cos(this.angle) * this.speed,
        velY = Math.sin(this.angle) * this.speed,
        checkPointX = this.x + (Math.cos(this.angle) * 8),
        checkPointY = this.y + (Math.sin(this.angle) * 8),
        imageData = ctx.getImageData(checkPointX, checkPointY, 3, 3),
        pxlData = imageData.data,
        collision = false;

        // check if its in bounds.
        if (checkPointX > 0 && checkPointX < window.innerWidth && checkPointY > 0 && checkPointY < window.innerHeight) {
            // check if the point in front is clear or not.
            for (var i = 0, n = pxlData.length; i < n; i += 4) {
                var alpha = imageData.data[i + 3];

                if (alpha !== 0) {
                    collision = true;
                    break;
                }
            }
        } else {
            collision = true;
        }

        // no collision keep moving
        if (!collision) {
            this.trapCount = 0;
            this.x += velX;
            this.y += velY;
        } else {
            // collision, assume its not the end
            this.trapCount++;
            this.angle -= 45 * (Math.PI / 180);

            // line is fully trapped make sure to draw an arc and start a new trace.            
            if (this.trapCount >= 7) {
                this.live = false;

                if (traces.length < settings.totalTraces) {
                    traces.push(new Trace({
                        cX: 0,
                        cY: 0
                    }));
                }
            }

            if (Math.sqrt(dx * dx + dy * dy) > 4) {
                this.points.push({
                    x: this.x,
                    y: this.y
                });
                this.lastPoint = this.points[this.points.length - 1];
            } else {
                this.trapCount++;
                this.x = this.lastPoint.x;
                this.y = this.lastPoint.y;
            }
        }
    } else {
        // small chance we might just stop altogether.
        if (Math.random() > 0.8) {
            this.live = false;
        }
        // no collision clear any prev trap checks, change the direction and continue on.
        this.trapCount = 0;
        this.angle += 45 * (Math.PI / 180);

        if (Math.sqrt(dx * dx + dy * dy) > 4) {
            this.points.push({
                x: this.x,
                y: this.y
            });
            this.lastPoint = this.points[this.points.length - 1];
        } else {
            this.x = this.lastPoint.x;
            this.y = this.lastPoint.y;
        }
    }
};

Trace.prototype.render = function () {
    ctx.beginPath();
    ctx.moveTo(this.points[0].x, this.points[0].y);

    for (var p = 1, plen = this.points.length; p < plen; p++) {
        ctx.lineTo(this.points[p].x, this.points[p].y);
    }
    ctx.lineTo(this.x, this.y);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(this.points[0].x, this.points[0].y, 4, 0, Math.PI * 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    if (!this.live) {
        ctx.beginPath();
        ctx.arc(this.points[plen - 1].x, this.points[plen - 1].y, 4, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
};

// init
var traces = [],
traceNum = settings.startTraces,
reqAnimFrameInstance = null;

for (var b = 0; b < traceNum; b++) {
    traces.push(new Trace({
        cX: 0,
        cY: 0
    }));
}

function reinit() {
    cancelAnimationFrame(reqAnimFrameInstance);
    traces = [];
    traceNum = settings.startTraces;
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

    for (var b = 0; b < traceNum; b++) {
        traces.push(new Trace({
            cX: 0,
            cY: 0
        }));
    }
    doTrace();
}

ctx.strokeStyle = "#1de9b6";
ctx.fillStyle = "#242424";
ctx.lineWidth = 1;

function doTrace() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

    for (var b = 0; b < traces.length; b++) {
        traces[b].render();
    }

    for (b = 0; b < traces.length; b++) {
        if (traces[b].live) {
            traces[b].update();
        }
    }
    reqAnimFrameInstance = requestAnimationFrame(doTrace);
}

doTrace();
</script>
</body>
</html>